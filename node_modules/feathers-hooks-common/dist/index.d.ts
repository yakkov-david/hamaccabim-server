import * as _feathersjs_feathers from '@feathersjs/feathers';
import { HookContext, Id, Application, Service, Query, Paginated, Params } from '@feathersjs/feathers';
import { GraphQLFieldResolver, parse } from 'graphql';
import { Ajv, Options, ErrorObject } from 'ajv';

declare const hookTypes: readonly ["around", "before", "after", "error"];
type HookType = typeof hookTypes[number];
declare const methodNames: readonly ["find", "get", "create", "update", "patch", "remove"];
type MethodName = typeof methodNames[number];
type TransportName = 'socketio' | 'rest' | 'external' | 'server';
type SyncContextFunction<T, H extends HookContext = HookContext> = (context: H) => T;
type AsyncContextFunction<T, H extends HookContext = HookContext> = (context: H) => Promise<T>;
type ContextFunction<T, H extends HookContext = HookContext> = (context: H) => T | Promise<T>;
type SyncPredicateFn<H extends HookContext = HookContext> = SyncContextFunction<boolean, H>;
type AsyncPredicateFn<H extends HookContext = HookContext> = AsyncContextFunction<boolean, H>;
type PredicateFn<H extends HookContext = HookContext> = ContextFunction<boolean, H>;
declare type HookFunction<H extends HookContext = HookContext> = (context: H) => Promise<H | void> | H | void;

/**
 * Runs a series of hooks which mutate context.data or context.result (the Feathers default).
 * @see https://hooks-common.feathersjs.com/hooks.html#actondefault
 */
declare const actOnDefault: <H extends HookContext<_feathersjs_feathers.Application<any, any>, any> = HookContext<_feathersjs_feathers.Application<any, any>, any>>(...hooks: HookFunction<H>[]) => (context: H) => Promise<H>;
/**
 * Runs a series of hooks which mutate context.dispatch.
 * @see https://hooks-common.feathersjs.com/hooks.html#actondispatch
 */
declare const actOnDispatch: <H extends HookContext<_feathersjs_feathers.Application<any, any>, any> = HookContext<_feathersjs_feathers.Application<any, any>, any>>(...hooks: HookFunction<H>[]) => (context: H) => Promise<H>;

/**
 * Make changes to data or result items. Very flexible.
 * @see https://hooks-common.feathersjs.com/hooks.html#alteritems
 */
declare function alterItems<T = any, H extends HookContext = HookContext>(cb: (record: T, context: H) => any): (context: H) => H | Promise<H>;

type CacheMap<T> = Map<string | number, T>;
interface CacheOptions<T> {
    clone?(item: T): T;
    makeCacheKey?(id: Id): string;
}
/**
 * Persistent, most-recently-used record cache for services.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#cache
 */
declare function cache<H extends HookContext = HookContext, T = any>(cacheMap: CacheMap<T>, keyField?: string, options?: CacheOptions<T>): (context: H) => H;

/**
 * Like checkContext, but only if the given type matches the hook's type.
 * Restrict a hook to run for certain methods and method types. (Utility function.)
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#checkcontextif
 */
declare function checkContextIf<H extends HookContext = HookContext>(context: H, type: HookType | HookType[], methods?: MethodName | MethodName[] | null, label?: string): void;

/**
 * Display the current hook context for debugging.
 * @see https://hooks-common.feathersjs.com/hooks.html#debug
 */
declare function debug<H extends HookContext = HookContext>(msg: string, ...fieldNames: string[]): (context: H) => void;

/**
 * Remove records and properties created by the populate hook.
 * @see https://hooks-common.feathersjs.com/hooks.html#depopulate
 */
declare function dePopulate<H extends HookContext = HookContext>(func?: (item: any) => void): (context: H) => H;

/**
 * Disables pagination when query.$limit is -1 or '-1'.
 * @see https://hooks-common.feathersjs.com/hooks.html#disablepagination
 */
declare function disablePagination<H extends HookContext = HookContext>(): (context: H) => H;

/**
 * Prevents access to a service method completely or for specific transports.
 * @see https://hooks-common.feathersjs.com/hooks.html#disallow
 */
declare function disallow<H extends HookContext = HookContext>(...transports: TransportName[]): (context: H) => void;

/**
 * Delete certain fields from the record(s).
 * @see https://hooks-common.feathersjs.com/hooks.html#discard
 */
declare function discard<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

/**
 * Delete certain fields from the query object.
 * @see https://hooks-common.feathersjs.com/hooks.html#discardquery
 */
declare function discardQuery<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

interface ResolverContext<A extends Application = Application, S extends Service = Service> extends HookContext<A, S> {
    _loaders: any;
}
type SimpleResolver<H extends ResolverContext = ResolverContext> = (...args: any[]) => (item: any, context: H) => Promise<any>;
interface RecursiveResolver<H extends ResolverContext = ResolverContext> {
    resolver: SimpleResolver<H>;
    joins: ResolverMap<any>;
}
interface ResolverMap<H extends ResolverContext = ResolverContext> {
    after?: (context: H) => void | Promise<void>;
    before?: (context: H) => void | Promise<void>;
    joins: {
        [property: string]: SimpleResolver<H> | RecursiveResolver<H>;
    };
}
/**
 * We often want to combine rows from two or more tables based on a relationship between them. The fastJoin hook
 * will select records that have matching values in both tables. It can batch service calls and cache records,
 * thereby needing roughly an order of magnitude fewer database calls than the populate hook, i.e. 2 calls instead
 * of 20. It uses a GraphQL-like imperative API.
 *
 * fastJoin is not restricted to using data from Feathers services. Resources for which there are no Feathers
 * adapters can also be used.
 *
 *
 * fastJoin(postResolvers)
 * fastJoin(postResolvers, query)
 * fastJoin(context => postResolvers)
 * fastJoin(postResolvers, context => query) // supports queries from client
 * @see https://hooks-common.feathersjs.com/hooks.html#fastjoin
 */
declare function fastJoin<H extends ResolverContext = ResolverContext>(resolvers: ResolverMap<H> | SyncContextFunction<ResolverMap<H>, H>, query?: Query | SyncContextFunction<Query, H>): (context: H) => H | Promise<H>;

type FGraphQLResolverMapFactory = (app: Application, runtime: any) => FGraphQLResolverMap;
interface FGraphQLResolverMap {
    [i: string]: {
        [i: string]: GraphQLFieldResolver<any, any>;
    };
    Query: {
        [i: string]: GraphQLFieldResolver<any, any>;
    };
}
interface FGraphQLOptions<H extends HookContext = HookContext> {
    skipHookWhen?: SyncContextFunction<boolean, H>;
    inclAllFieldsServer?: boolean;
    inclAllFieldsClient?: boolean;
    inclAllFields?: boolean;
    inclJoinedNames?: boolean;
    extraAuthProps?: string[];
}
interface FGraphQLHookOptions<H extends HookContext = HookContext> {
    recordType: string;
    schema: string;
    resolvers: FGraphQLResolverMap | FGraphQLResolverMapFactory;
    query: Query | SyncContextFunction<Query, H>;
    options?: FGraphQLOptions<H>;
    runTime: any;
    parse: typeof parse;
}
/**
 * Generate Graphql Resolvers for services
 * @see https://medium.com/@eddyystop/38faee75dd1
 */
declare function fgraphql<H extends HookContext = HookContext>(options1: FGraphQLHookOptions<H>): (context: H) => any;

interface IffHook<H extends HookContext = HookContext> extends HookFunction<H> {
    else(...hooks: HookFunction<H>[]): HookFunction<H>;
}
/**
 * Execute one or another series of hooks depending on a sync or async predicate.
 * @see https://hooks-common.feathersjs.com/hooks.html#iff
 */
declare function iff<H extends HookContext = HookContext>(predicate: boolean | PredicateFn<H>, ...hooks: HookFunction<H>[]): IffHook<H>;

/**
 * Execute one array of hooks or another based on a sync or async predicate.
 * @see https://hooks-common.feathersjs.com/hooks.html#iffelse
 */
declare function iffElse<H extends HookContext = HookContext>(predicate: boolean | PredicateFn<H>, trueHook: HookFunction<H> | HookFunction<H>[] | undefined, falseHook?: HookFunction<H> | HookFunction<H>[] | undefined): (this: any, ctx: H) => HookContext<_feathersjs_feathers.Application<any, any>, any> | Promise<HookContext<_feathersjs_feathers.Application<any, any>, any>>;

/**
 * Keep certain fields in the record(s), deleting the rest.
 * @see https://hooks-common.feathersjs.com/hooks.html#keep
 */
declare function keep<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

/**
 * Keep certain fields in a nested array inside the record(s), deleting the rest.
 * @see https://hooks-common.feathersjs.com/hooks.html#keepinarray
 */
declare function keepInArray<H extends HookContext = HookContext>(arrayName: string, fieldNames: string[]): (context: H) => H;

/**
 * Keep certain fields in the query object, deleting the rest.
 * @see https://hooks-common.feathersjs.com/hooks.html#keepquery
 */
declare function keepQuery<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

/**
 * Keep certain fields in a nested array inside the query object, deleting the rest.
 * @see https://hooks-common.feathersjs.com/hooks.html#keepqueryinarray
 */
declare function keepQueryInArray<H extends HookContext = HookContext>(arrayName: string, fieldNames: string[]): (context: H) => H;

/**
 * Convert certain field values to lower case.
 * @see https://hooks-common.feathersjs.com/hooks.html#lowercase
 */
declare function lowerCase<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

/**
 * Wrap MongoDB foreign keys in ObjectId.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#mongokeys
 */
declare function mongoKeys<H extends HookContext = HookContext>(ObjectId: new (id?: string | number) => any, keyFields: string | string[]): (context: H) => H;

/**
 * Pass context.params from client to server. Server hook.
 * @see https://hooks-common.feathersjs.com/hooks.html#paramsfromclient
 */
declare function paramsFromClient<H extends HookContext = HookContext>(...whitelist: string[]): (context: H) => H;

interface PopulateOptions<H extends HookContext = HookContext> {
    schema: Partial<PopulateSchema> | ((context: H, options: PopulateOptions<H>) => Partial<PopulateSchema>);
    checkPermissions?: (context: H, path: string, permissions: any, depth: number) => boolean;
    profile?: boolean;
}
interface PopulateSchema {
    /**
     * The name of the service providing the items, actually its path.
     */
    service: string;
    /**
     * Where to place the items from the join
     * dot notation
     */
    nameAs: string;
    /**
     * The name of the field in the parent item for the relation.
     * dot notation
     */
    parentField: string;
    /**
     * The name of the field in the child item for the relation.
     * Dot notation is allowed and will result in a query like { 'name.first': 'John' } which is not suitable for all DBs.
     * You may use query or select to create a query suitable for your DB.
     */
    childField: string;
    /**
     * Who is allowed to perform this join. See checkPermissions above.
     */
    permissions: any;
    /**
     * An object to inject into context.params.query.
     */
    query: any;
    /**
     * A function whose result is injected into the query.
     */
    select: (context: HookContext, parentItem: any, depth: number) => any;
    /**
     * Force a single joined item to be stored as an array.
     */
    asArray: boolean;
    /**
     * Controls pagination for this service.
     */
    paginate: boolean | number;
    /**
     * Perform any populate or fastJoin registered on this service.
     */
    useInnerPopulate: boolean;
    /**
     * Call the service as the server, not with the client’s transport.
     */
    provider: string;
    include: Partial<PopulateSchema> | Partial<PopulateSchema>[];
}
declare function populate<H extends HookContext = HookContext>(options: PopulateOptions<H>): (context: H) => H | Promise<H>;

/**
 * Prevent patch service calls from changing certain fields.
 * @see https://hooks-common.feathersjs.com/hooks.html#preventchanges
 */
declare function preventChanges<H extends HookContext = HookContext>(ifThrow: boolean, ...fieldNames: string[]): (context: H) => H;

/**
 * Check selected fields exist and are not falsey. Numeric 0 is acceptable.
 * @see https://hooks-common.feathersjs.com/hooks.html#required
 */
declare function required<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => void;

/**
 * Let's you call a hook right after the service call. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#runhook
 */
declare function runHook<H extends HookContext = HookContext>(context?: H): (hook: any) => (data: any[] | Paginated<any>) => Promise<any>;

/**
 * Run a hook in parallel to the other hooks and the service call.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#runparallel
 */
declare function runParallel<H extends HookContext = HookContext>(hook: HookFunction<H>, clone?: (item: H) => H): (this: any, context: H) => void;

interface SequelizeConversion {
    js: (sqlValue: any) => any;
    sql: (jsValue: any) => any;
}
interface SequelizeConverts<C> {
    [name: string]: keyof C | 'boolean' | 'date' | 'json';
}
/**
 * @see https://hooks-common.feathersjs.com/hooks.html#sequelizeconvert
 */
declare function sequelizeConvert<C extends {
    [name: string]: SequelizeConversion;
}, H extends HookContext = HookContext>(converts: SequelizeConverts<C> | null | undefined | false, ignores?: string[] | null | undefined | false, conversions?: C): (context: H) => H;

interface SerializeSchema<H extends HookContext = HookContext> {
    only?: string | string[];
    exclude?: string | string[];
    computed?: {
        [propName: string]: (record: any, context: H) => any;
    };
    [key: string]: SerializeSchema<H> | SerializeSchema<H>['computed'] | string | string[] | undefined;
}
/**
 * Prune values from related records. Calculate new values.
 * @see https://hooks-common.feathersjs.com/hooks.html#serialize
 */
declare function serialize<H extends HookContext = HookContext>(schema1: SerializeSchema<H> | SyncContextFunction<SerializeSchema, H>): (context: H) => H;

interface SetFieldOptions {
    as: string;
    from: string;
    allowUndefined?: boolean;
}
/**
 * The `setField` hook allows to set a field on the hook context based on the value of another field on the hook context.
 * @see https://hooks-common.feathersjs.com/hooks.html#setfield
 */
declare function setField<H extends HookContext = HookContext>({ as, from, allowUndefined, }: SetFieldOptions): (context: H) => H;

/**
 * Create/update certain fields to the current date-time.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#setnow
 */
declare function setNow<H extends HookContext = HookContext>(...fieldNames: string[]): (context: H) => H;

/**
 * Fix slugs in URL, e.g. /stores/:storeId.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#setslug
 */
declare function setSlug<H extends HookContext = HookContext>(slug: string, fieldName?: string): (context: H) => void;

declare function sifter<H extends HookContext = HookContext>(siftFunc: SyncContextFunction<(item: any) => boolean, H>): (context: H) => H;

type SoftDeleteOptionFunction<H extends HookContext = HookContext> = (context?: H) => Promise<{
    [key: string]: any;
}>;
interface SoftDeleteOptions<H extends HookContext = HookContext> {
    deletedQuery?: {
        [key: string]: any;
    } | SoftDeleteOptionFunction<H>;
    removeData?: {
        [key: string]: any;
    } | SoftDeleteOptionFunction<H>;
}
/**
 * Allow to mark items as deleted instead of removing them.
 */
declare function softDelete<H extends HookContext = HookContext>({ deletedQuery, removeData, }?: SoftDeleteOptions<H>): (context: H) => Promise<H>;

/**
 * Stash current value of record, usually before mutating it. Performs a get call.
 * @see https://hooks-common.feathersjs.com/hooks.html#stashbefore
 */
declare function stashBefore<H extends HookContext = HookContext>(fieldName?: string): (context: H) => any;

/**
 * Transform fields & objects in place in the record(s) using a recursive walk. Powerful.
 * Check docs at https://github.com/substack/js-traverse for info on transformContext!
 * @see https://hooks-common.feathersjs.com/hooks.html#traverse
 */
declare function traverse<H extends HookContext = HookContext>(transformer: (transformContext: any) => any, getObject?: SyncContextFunction<any, H>): (context: H) => H;

/**
 * Execute a series of hooks if a sync or async predicate is falsey.
 *
 * @see https://hooks-common.feathersjs.com/hooks.html#unless
 */
declare function unless<H extends HookContext = HookContext>(predicate: boolean | PredicateFn, ...hooks: HookFunction<H>[]): (this: any, ctx: H) => HookContext<_feathersjs_feathers.Application<any, any>, any> | Promise<HookContext<_feathersjs_feathers.Application<any, any>, any>>;

type SyncValidatorFn<H extends HookContext = HookContext> = (values: any, context: H) => {
    [key: string]: string;
} | null;
type AsyncValidatorFn<H extends HookContext = HookContext> = (values: any, context: H) => Promise<object | null>;
type ValidatorFn<H extends HookContext = HookContext> = SyncValidatorFn<H> | AsyncValidatorFn<H>;
type AjvOrNewable = Ajv | (new (options?: Options) => Ajv);
interface ValidateSchemaOptions extends Options {
    /**
     * The hook will throw if the data does not match the JSON-Schema. error.errors will, by default, contain an array
     * of error messages. You may change this with a custom formatting function. Its a reducing function which works
     * similarly to Array.reduce().
     */
    addNewError: (currentFormattedMessages: any, ajvErrorObject: ErrorObject, itemsLen: number, itemIndex: number) => any;
}
/**
 * Validate data using a validation function.
 * @see https://hooks-common.feathersjs.com/hooks.html#validate
 */
declare function validate<H extends HookContext = HookContext>(validator: ValidatorFn): (context: H) => H | Promise<H>;

/**
 * Validate data using JSON-Schema.
 * @see https://hooks-common.feathersjs.com/hooks.html#validateschema
 */
declare function validateSchema<H extends HookContext = HookContext>(schema: object | string, ajvOrAjv: AjvOrNewable, options?: ValidateSchemaOptions): (context: H) => Promise<void> | H;

type Disablable = 'populate' | 'fastJoin' | 'ignoreDeletedAt' | 'softDelete' | 'softDelete2' | 'stashBefore';
interface CallingParamsOptions {
    /**
     * The params.query for the calling params.
     */
    query?: any;
    /**
     * The names of the props in context.params to include in the new params.
     */
    propNames?: string[];
    /**
     * Additional props to add to the new params.
     */
    newProps?: any;
    /**
     * The names of hooks to disable during the service call. populate, fastJoin, softDelete and stashBefore are supported.
     */
    hooksToDisable?: Disablable[] | Disablable;
    /**
     *    Ignore the defaults propNames and newProps.
     */
    ignoreDefaults?: boolean;
}
/**
 * Set defaults for building params for service calls with callingParams. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#callingparamsdefaults
 */
declare function callingParamsDefaults(propNames: string[], newProps?: any): void;
/**
 * Build params for a service call. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#callingparams
 */
declare function callingParams<H extends HookContext = HookContext>({ query, propNames, newProps, hooksToDisable, ignoreDefaults, }?: CallingParamsOptions): (context: H) => Params<_feathersjs_feathers.Query>;
/**
 * You should prefer using the callingParams utility to makeCallingParams.
 * Build context.params for service calls. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#makecallingparams
 */
declare function makeCallingParams<H extends HookContext = HookContext>(context: H, query?: any, include?: string | string[], inject?: {}): Params<_feathersjs_feathers.Query>;

/**
 * Restrict a hook to run for certain methods and method types. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#checkcontext
 */
declare function checkContext<H extends HookContext = HookContext>(context: H, type?: HookType | HookType[] | null, methods?: MethodName | MethodName[] | null, label?: string): void;

/**
 * Sequentially execute multiple sync or async hooks.
 * @see https://hooks-common.feathersjs.com/utilities.html#combine
 */
declare function combine<H extends HookContext = HookContext>(...serviceHooks: HookFunction<H>[]): (context: H) => Promise<H>;

/**
 * Return the and of a series of sync or async predicate functions.
 * @see https://hooks-common.feathersjs.com/utilities.html#every
 */
declare function every<H extends HookContext = HookContext>(...predicates: PredicateFn<H>[]): AsyncPredicateFn<H>;

/**
 * Get the records in context.data or context.result[.data]. (Utility function.)
 *
 * @see https://hooks-common.feathersjs.com/utilities.html#getitems
 */
declare function getItems<H extends HookContext = HookContext>(context: H): any;

/**
 * Negate a sync or async predicate function.
 *
 * @see https://hooks-common.feathersjs.com/utilities.html#isnot
 */
declare function isNot<H extends HookContext = HookContext>(predicate: boolean | PredicateFn<H>): PredicateFn<H>;

/**
 * Check which transport provided the service call.
 * @see https://hooks-common.feathersjs.com/utilities.html#isprovider
 */
declare function isProvider<H extends HookContext = HookContext>(...providers: TransportName[]): (context: H) => boolean;

/**
 * Pass an explicit context.params from client to server. Client-side. (Utility function.)
 *
 * @see https://hooks-common.feathersjs.com/utilities.html#paramsforserver
 */
declare function paramsForServer(params?: Params, ...whitelist: string[]): Params;

/**
 * Replace the records in context.data or context.result[.data]. (Utility function.)
 * @see https://hooks-common.feathersjs.com/utilities.html#replaceitems
 */
declare function replaceItems<H extends HookContext = HookContext>(context: H, items: any): void;

/**
 * Return the or of a series of sync or async predicate functions.
 * @see https://hooks-common.feathersjs.com/utilities.html#some
 */
declare function some<H extends HookContext = HookContext>(...predicates: PredicateFn<H>[]): AsyncPredicateFn<H>;

export { type AjvOrNewable, type AsyncContextFunction, type AsyncPredicateFn, type AsyncValidatorFn, type CacheMap, type CacheOptions, type CallingParamsOptions, type ContextFunction, type Disablable, type FGraphQLHookOptions, type FGraphQLOptions, type FGraphQLResolverMap, type FGraphQLResolverMapFactory, type HookFunction, type HookType, type IffHook, type MethodName, type PopulateOptions, type PopulateSchema, type PredicateFn, type RecursiveResolver, type ResolverContext, type ResolverMap, type SequelizeConversion, type SequelizeConverts, type SerializeSchema, type SetFieldOptions, type SimpleResolver, type SoftDeleteOptionFunction, type SoftDeleteOptions, type SyncContextFunction, type SyncPredicateFn, type SyncValidatorFn, type TransportName, type ValidateSchemaOptions, type ValidatorFn, actOnDefault, actOnDispatch, alterItems, cache, callingParams, callingParamsDefaults, checkContext, checkContextIf, combine, dePopulate, debug, disablePagination, disallow, discard, discardQuery, every, fastJoin, fgraphql, getItems, hookTypes, iff, iffElse, isNot, isProvider, keep, keepInArray, keepQuery, keepQueryInArray, lowerCase, makeCallingParams, methodNames, mongoKeys, paramsForServer, paramsFromClient, populate, preventChanges, replaceItems, required, runHook, runParallel, sequelizeConvert, serialize, setField, setNow, setSlug, sifter, softDelete, some, stashBefore, traverse, unless, validate, validateSchema, iff as when };
