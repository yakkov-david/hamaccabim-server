'use strict';

var errors = require('@feathersjs/errors');
var _pick = require('lodash/pick.js');
var _set3 = require('lodash/set.js');
var _get3 = require('lodash/get.js');
var traverser = require('traverse');
var _omit = require('lodash/omit.js');
var makeDebug = require('debug');
var _has = require('lodash/has.js');
var _setWith = require('lodash/setWith.js');
var _clone = require('lodash/clone.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var _pick__default = /*#__PURE__*/_interopDefault(_pick);
var _set3__default = /*#__PURE__*/_interopDefault(_set3);
var _get3__default = /*#__PURE__*/_interopDefault(_get3);
var traverser__default = /*#__PURE__*/_interopDefault(traverser);
var _omit__default = /*#__PURE__*/_interopDefault(_omit);
var makeDebug__default = /*#__PURE__*/_interopDefault(makeDebug);
var _has__default = /*#__PURE__*/_interopDefault(_has);
var _setWith__default = /*#__PURE__*/_interopDefault(_setWith);
var _clone__default = /*#__PURE__*/_interopDefault(_clone);

// src/utils/combine.ts
function combine(...serviceHooks) {
  const isContext = function(ctx) {
    return typeof ctx?.method === "string" && typeof ctx?.type === "string";
  };
  return async function(context) {
    let ctx = context;
    const updateCurrentHook = (current) => {
      if (current) {
        if (!isContext(current)) {
          throw new Error(
            `${ctx.type} hook for '${ctx.method}' method returned invalid hook object`
          );
        }
        ctx = current;
      }
      return ctx;
    };
    const promise = serviceHooks.reduce(async (current, fn) => {
      const hook = fn.bind(this);
      const currentHook = await current;
      const currentCtx = await hook(currentHook);
      return updateCurrentHook(currentCtx);
    }, Promise.resolve(ctx));
    try {
      await promise;
      return ctx;
    } catch (error) {
      error.hook = ctx;
      throw error;
    }
  };
}

// src/hooks/act-on-dispatch.ts
var actOnDefault = (...hooks) => actOn(void 0, ...hooks);
var actOnDispatch = (...hooks) => actOn("dispatch", ...hooks);
function actOn(what, ...hooks) {
  return async (context) => {
    const currActOn = context.params._actOn;
    context.params._actOn = what;
    const newContext = await combine(...hooks)(context);
    newContext.params._actOn = currActOn;
    return newContext;
  };
}
function pluck(items, fieldNames) {
  if (!Array.isArray(items)) {
    return _pick__default.default(items, fieldNames);
  }
  const pluckedItems = (Array.isArray(items) ? items : [items]).map(
    (item) => _pick__default.default(item, fieldNames)
  );
  return pluckedItems;
}
function setFields(items, fieldValue, fieldNames, defaultFieldName) {
  const value = typeof fieldValue === "function" ? fieldValue() : fieldValue;
  if (!fieldNames.length)
    fieldNames = [defaultFieldName];
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    fieldNames.forEach((fieldName) => {
      _set3__default.default(item, fieldName, value);
    });
  });
}
function transformItems(items, fieldNames, transformer) {
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    fieldNames.forEach((fieldName) => {
      transformer(item, fieldName, _get3__default.default(item, fieldName));
    });
  });
}
function traverse(items, converter) {
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    traverser__default.default(item).forEach(converter);
  });
}

// src/common/clone.ts
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// src/common/index.ts
function isPromise(p) {
  return !!p && (typeof p === "object" || typeof p === "function") && typeof p.then === "function";
}

// src/utils/get-items.ts
function getItems(context) {
  if (context.params && context.params._actOn === "dispatch")
    return context.dispatch;
  const items = context.type === "before" ? context.data : context.result;
  return items && context.method === "find" ? items.data || items : items;
}

// src/utils/replace-items.ts
function replaceItems(context, items) {
  if (context.params && context.params._actOn === "dispatch") {
    context.dispatch = items;
    return;
  }
  if (context.type === "before") {
    context.data = items;
  } else if (context.method === "find" && context.result && context.result.data) {
    context.result.data = Array.isArray(items) ? items : [items];
  } else {
    context.result = items;
  }
}

// src/hooks/alter-items.ts
function alterItems(cb) {
  if (!cb) {
    cb = () => {
    };
  }
  if (typeof cb !== "function") {
    throw new errors.BadRequest("Function required. (alter)");
  }
  return (context) => {
    let items = getItems(context);
    const isArray2 = Array.isArray(items);
    const results = (isArray2 ? items : [items]).map((item) => cb(item, context));
    const hasPromises = results.some((result) => isPromise(result));
    const setItem = (value, index) => {
      if (typeof value === "object" && value !== null) {
        if (isArray2) {
          items[index] = value;
        } else {
          items = value;
        }
      }
    };
    if (hasPromises) {
      return Promise.all(results).then((values) => {
        values.forEach(setItem);
        replaceItems(context, items);
        return context;
      });
    } else {
      results.forEach(setItem);
      replaceItems(context, items);
      return context;
    }
  };
}

// src/hooks/cache.ts
var defaultMakeCacheKey = (key) => key;
function cache(cacheMap, keyField, options) {
  const clone2 = options?.clone || clone;
  const makeCacheKey = options?.makeCacheKey || defaultMakeCacheKey;
  return (context) => {
    keyField = keyField || context.service?.id;
    let items = getItems(context);
    items = Array.isArray(items) ? items : [items];
    const query = context.params.query || {};
    if (context.type === "after") {
      if (context.method === "remove") {
        items.forEach((item) => {
          const idName = getIdName(keyField, item);
          const key = makeCacheKey(item[idName]);
          cacheMap.delete(key);
        });
        return context;
      }
      if (query.$select)
        return context;
      items.forEach((item) => {
        const idName = getIdName(keyField, item);
        const key = makeCacheKey(item[idName]);
        cacheMap.set(key, clone2(item));
      });
      return context;
    }
    switch (context.method) {
      case "find":
      case "remove":
      case "create":
        return context;
      case "get": {
        if (!Object.keys(query).length) {
          const key = makeCacheKey(context.id);
          const value = cacheMap.get(key);
          if (value)
            context.result = value;
        }
        return context;
      }
      default:
        if (context.id) {
          cacheMap.delete(context.id);
          return context;
        }
        items.forEach((item) => {
          const idName = getIdName(keyField, item);
          const key = makeCacheKey(item[idName]);
          cacheMap.delete(key);
        });
    }
    return context;
  };
}
function getIdName(keyField, item) {
  if (keyField)
    return keyField;
  return "_id" in item ? "_id" : "id";
}

// src/types.ts
var hookTypes = ["around", "before", "after", "error"];
var methodNames = ["find", "get", "create", "update", "patch", "remove"];

// src/utils/check-context.ts
function checkContext(context, type, methods, label = "anonymous") {
  if (type) {
    const types = Array.isArray(type) ? type : [type];
    if (!types.includes(context.type)) {
      throw new Error(`The '${label}' hook can only be used as a '${type}' hook.`);
    }
  }
  if (!methods) {
    return;
  }
  if (!methodNames.includes(context.method)) {
    return;
  }
  const methodsArr = Array.isArray(methods) ? methods : [methods];
  if (methodsArr.length > 0 && !methodsArr.includes(context.method)) {
    const msg = JSON.stringify(methodsArr);
    throw new Error(`The '${label}' hook can only be used on the '${msg}' service method(s).`);
  }
}

// src/utils/check-context-if.ts
function checkContextIf(context, type, methods, label) {
  if (Array.isArray(type) ? !type.includes(context.type) : type !== context.type) {
    return;
  }
  checkContext(context, type, methods, label);
}

// src/hooks/debug.ts
function debug(msg, ...fieldNames) {
  return (context) => {
    const now = /* @__PURE__ */ new Date();
    console.log(
      `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()} ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`
    );
    if (msg) {
      console.log(msg);
    }
    console.log(`${context.type} service('${context.path}').${context.method}()`);
    if (!["find", "create"].includes(context.method) && "id" in context) {
      console.log("id:", context.id);
    }
    if (context.data) {
      console.log("data:", context.data);
    }
    if (context.params?.query) {
      console.log("query:", context.params.query);
    }
    if (context.result) {
      console.log("result:", context.result);
    }
    const params = context.params || {};
    console.log("params props:", Object.keys(params).sort());
    fieldNames.forEach((name) => {
      console.log(`params.${name}:`, params[name]);
    });
    if (context.error) {
      console.log("error", context.error);
    }
  };
}
function dePopulate(func) {
  return (context) => {
    const items = getItems(context);
    const converter = (item) => {
      if (typeof func === "function") {
        func(item);
      }
      const keys = ["_elapsed", "_computed", "_include"];
      const { _computed = [], _include = [] } = item;
      return _omit__default.default(item, keys.concat(_computed).concat(_include));
    };
    const converted = Array.isArray(items) ? items.map(converter) : converter(items);
    replaceItems(context, converted);
    return context;
  };
}

// src/hooks/disable-pagination.ts
function disablePagination() {
  return (context) => {
    checkContext(context, "before", ["find"], "disablePagination");
    const $limit = (context.params.query || {}).$limit;
    if ($limit === "-1" || $limit === -1) {
      context.params.paginate = false;
      delete context.params.query.$limit;
    }
    return context;
  };
}
function disallow(...transports) {
  return (context) => {
    const hookProvider = context.params?.provider;
    const anyProvider = transports.length === 0;
    const thisProvider = transports.some(
      (provider) => provider === hookProvider || provider === "server" && !hookProvider || provider === "external" && !!hookProvider
    );
    if (anyProvider || thisProvider) {
      throw new errors.MethodNotAllowed(
        `Provider '${context.params.provider}' can not call '${context.method}'. (disallow)`
      );
    }
  };
}
function discard(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "discard");
    const items = getItems(context);
    const convert = (item) => _omit__default.default(item, fieldNames);
    const converted = Array.isArray(items) ? items.map(convert) : convert(items);
    replaceItems(context, converted);
    return context;
  };
}
function discardQuery(...fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "discardQuery");
    const query = context.params.query || {};
    context.params.query = _omit__default.default(query, fieldNames);
    return context;
  };
}

// src/hooks/fast-join.ts
function fastJoin(resolvers, query) {
  return (context) => {
    const { method, data, result, params } = context;
    if (params._populate || params._graphql)
      return context;
    const q = typeof query === "function" ? query(context) : query;
    const joins2 = typeof resolvers === "function" ? resolvers(context) : resolvers;
    const { before, joins, after } = joins2;
    const temp = result || (Array.isArray(data) ? data : [data]);
    const results = method === "find" ? result.data || temp : temp;
    const prevLoaders = context._loaders;
    context._loaders = {};
    return Promise.resolve().then(() => before && before(context)).then(
      () => joins && results && recursive(joinsForQuery(joins2, q, context), results, context)
    ).then(() => after && after(context)).then(() => {
      context._loaders = prevLoaders;
      return context;
    });
  };
}
function joinsForQuery({ joins } = {}, query = void 0, context = {}) {
  const runtime = [];
  Object.keys(joins).forEach((outerLabel) => {
    if (query && !query[outerLabel])
      return;
    let join = joins[outerLabel];
    if (typeof join === "function") {
      join = { resolver: join };
    }
    const { resolver } = join;
    let { joins: innerJoins } = join;
    if (innerJoins && !innerJoins.resolver && innerJoins.joins) {
      innerJoins = innerJoins.joins;
    }
    let args = query ? query[outerLabel] : [];
    if (!Array.isArray(args)) {
      args = typeof args === "object" && args !== null ? args.args : [];
    }
    runtime.push({
      args,
      resolver,
      joins: innerJoins ? joinsForQuery({ joins: innerJoins }, query ? query[outerLabel] : null, context) : null
    });
  });
  return runtime;
}
function recursive(joins, results, context) {
  return Promise.all(
    (Array.isArray(results) ? results : [results]).map(
      (result) => Promise.all(
        joins.map(({ args = [], resolver, joins: joins2 }) => {
          return Promise.resolve(resolver(...args)(result, context)).then((addedResults) => {
            if (!addedResults || !joins2)
              return context;
            return recursive(joins2, addedResults, context);
          });
        })
      )
    )
  );
}
var debug2 = makeDebug__default.default("fgraphql");
var graphqlActions = ["Query", "Mutation", "Subscription"];
function fgraphql(options1) {
  debug2("init call");
  const { parse, recordType, resolvers, runTime, query } = options1;
  let { schema } = options1;
  let ourResolvers;
  const options = {
    skipHookWhen: (context) => !!(context.params || {}).graphql,
    inclAllFieldsServer: true,
    inclAllFieldsClient: true,
    inclAllFields: null,
    // Will be initialized each hook call.
    inclJoinedNames: true,
    extraAuthProps: [],
    ...options1.options || {}
  };
  schema = isFunction(schema) ? schema() : schema;
  if (!isObject(schema) && !isString(schema)) {
    throwError(
      `Resolved schema is typeof ${typeof schema} rather than string or object. (fgraphql)`,
      101
    );
  }
  if (!isObject(runTime)) {
    throwError(`option runTime is typeof ${typeof runTime} rather than an object. (fgraphql)`, 106);
  }
  if (!isString(recordType)) {
    throwError(`recordType is typeof ${typeof recordType} rather than string. (fgraphql)`, 103);
  }
  if (!isArray(options.extraAuthProps)) {
    throwError(
      `option extraAuthProps is typeof ${typeof options.extraAuthProps} rather than array. (fgraphql)`,
      105
    );
  }
  const feathersSdl = isObject(schema) ? schema : convertSdlToFeathersSchemaObject(schema, parse);
  debug2("schema now in internal form");
  return (context) => {
    const contextParams = context.params;
    const optSkipHookWhen = options.skipHookWhen;
    const skipHookWhen = isFunction(optSkipHookWhen) ? optSkipHookWhen(context) : optSkipHookWhen;
    debug2(
      `
.....hook called. type ${context.type} method ${context.method} resolved skipHookWhen ${skipHookWhen}`
    );
    if (context.params.$populate)
      return context;
    if (skipHookWhen)
      return context;
    const q = isFunction(query) ? query(context) : query;
    if (!isObject(q)) {
      throwError(`Resolved query is typeof ${typeof q} rather than object. (fgraphql)`, 102);
    }
    if (!ourResolvers) {
      ourResolvers = resolvers(context.app, runTime);
      debug2(`ourResolvers has Types ${Object.keys(ourResolvers)}`);
    }
    if (!ourResolvers[recordType]) {
      throwError(`recordType ${recordType} not found in resolvers. (fgraphql)`, 104);
    }
    options.inclAllFields = contextParams.provider ? (
      // @ts-ignore
      options.inclAllFieldsClient
    ) : (
      // @ts-ignore
      options.inclAllFieldsServer
    );
    debug2(`inclAllField ${options.inclAllFields}`);
    const resolverContent = {
      app: context.app,
      provider: contextParams.provider,
      user: contextParams.user,
      authenticated: contextParams.authenticated,
      batchLoaders: {},
      cache: {}
    };
    (options.extraAuthProps || []).forEach((name) => {
      if (name in contextParams && !(name in resolverContent)) {
        resolverContent[name] = contextParams[name];
      }
    });
    const store = {
      feathersSdl,
      ourResolvers,
      options,
      resolverContent
    };
    const recs = getItems(context);
    return processRecords(store, q, recs, recordType).then(() => {
      replaceItems(context, recs);
      return context;
    });
  };
}
function processRecords(store, query, recs, type, depth = 0) {
  if (!recs)
    return;
  recs = isArray(recs) ? recs : [recs];
  debug2(`
vvvvvvvvvv enter ${depth}`);
  debug2(`processRecords depth ${depth} #recs ${recs.length} Type ${type}`);
  const storeOurResolversType = store.ourResolvers[type];
  if (!isObject(storeOurResolversType)) {
    throwError(
      `Resolvers for Type ${type} are typeof ${typeof storeOurResolversType} not object. (fgraphql)`,
      201
    );
  }
  if (!isObject(query)) {
    throwError(`query at Type ${type} are typeof ${typeof query} not object. (fgraphql)`, 202);
  }
  return Promise.all(
    recs.map((rec, j) => processRecord(store, query, depth, rec, type, j))
  ).then(() => {
    debug2(`^^^^^^^^^^ exit ${depth}
`);
  });
}
function processRecord(store, query, depth, rec, type, j) {
  debug2(`processRecord rec# ${j} typeof ${typeof rec} Type ${type}`);
  if (!rec)
    return;
  const queryPropNames = Object.keys(query);
  const recFieldNamesInQuery = [];
  const joinedNamesInQuery = [];
  return Promise.all(
    queryPropNames.map(
      (fieldName, i) => processRecordQuery(
        store,
        query,
        depth,
        rec,
        fieldName,
        type,
        recFieldNamesInQuery,
        joinedNamesInQuery,
        j,
        i
      )
    )
  ).then(() => {
    debug2(`field names found ${recFieldNamesInQuery} joined names ${joinedNamesInQuery}`);
    if (recFieldNamesInQuery.length || !store.options.inclAllFields || queryPropNames.includes("_none")) {
      Object.keys(rec).forEach((key) => {
        if (!recFieldNamesInQuery.includes(key) && !joinedNamesInQuery.includes(key)) {
          delete rec[key];
        }
      });
    }
    if (store.options.inclJoinedNames && joinedNamesInQuery.length) {
      rec._include = joinedNamesInQuery;
    }
  });
}
function processRecordQuery(store, query, depth, rec, fieldName, type, recFieldNamesInQuery, joinedNamesInQuery, j, i) {
  debug2(`
processRecordQuery rec# ${j} Type ${type} field# ${i} name ${fieldName}`);
  if (query[fieldName] && fieldName !== "_args" && fieldName !== "_none") {
    if (store.ourResolvers[type][fieldName]) {
      joinedNamesInQuery.push(fieldName);
      return processRecordFieldResolver(store, query, depth, rec, fieldName, type);
    } else {
      debug2("is not resolver call");
      recFieldNamesInQuery.push(fieldName);
    }
  }
}
function processRecordFieldResolver(store, query, depth, rec, fieldName, type) {
  debug2("is resolver call");
  const ourQuery = store.feathersSdl[type][fieldName];
  const ourResolver = store.ourResolvers[type][fieldName];
  if (!isFunction(ourResolver)) {
    throwError(
      `Resolver for Type ${type} fieldName ${fieldName} is typeof ${typeof ourResolver} not function. (fgraphql)`,
      203
    );
  }
  const args = isObject(query[fieldName]) ? query[fieldName]._args : void 0;
  debug2(`resolver listType ${ourQuery.listType} args ${JSON.stringify(args)}`);
  return Promise.resolve(ourResolver(rec, args || {}, store.resolverContent)).then(
    async (rawResult) => {
      debug2(
        `resolver returned typeof ${isArray(rawResult) ? `array #recs ${rawResult.length}` : typeof rawResult}`
      );
      const result = convertResolverResult(rawResult, ourQuery, fieldName, type);
      if (isArray(rawResult !== isArray(result) || typeof rawResult !== typeof result)) {
        debug2(
          `.....resolver result converted to typeof ${isArray(result) ? `array #recs ${result.length}` : typeof result}`
        );
      }
      rec[fieldName] = result;
      const nextType = ourQuery.typeof;
      debug2(`Type ${type} fieldName ${fieldName} next Type ${nextType}`);
      if (store.ourResolvers[nextType] && isObject(query[fieldName])) {
        return processRecords(store, query[fieldName], result, nextType, depth + 1);
      } else {
        debug2("no population of results required");
      }
    }
  );
}
function convertResolverResult(result, ourQuery, fieldName, type) {
  if (result === null || result === void 0) {
    return ourQuery.listType ? [] : null;
  }
  if (ourQuery.listType) {
    if (!isArray(result))
      return [result];
  } else if (isArray(result)) {
    if (result.length > 1) {
      throwError(
        `Query listType true. Resolver for Type ${type} fieldName ${fieldName} result is array len ${result.length} (fgraphql)`,
        204
      );
    }
    return result[0];
  }
  return result;
}
function convertSdlToFeathersSchemaObject(schemaDefinitionLanguage, parse) {
  const graphQLSchemaObj = parse(schemaDefinitionLanguage);
  return convertDocument(graphQLSchemaObj);
}
function convertDocument(ast) {
  const result = {};
  if (ast.kind !== "Document" || !isArray(ast.definitions)) {
    throw new Error("Not a valid GraphQL Document.");
  }
  ast.definitions.forEach((definition, definitionIndex) => {
    const [objectName, converted] = convertObjectTypeDefinition(definition, definitionIndex);
    if (objectName) {
      result[objectName] = converted;
    }
  });
  return result;
}
function convertObjectTypeDefinition(definition, definitionIndex) {
  const converted = {};
  if (definition.kind !== "ObjectTypeDefinition" || !isArray(definition.fields)) {
    throw new Error(`Type# ${definitionIndex} is not a valid ObjectTypeDefinition`);
  }
  const objectTypeName = convertName(definition.name, `Type# ${definitionIndex}`);
  if (graphqlActions.includes(objectTypeName))
    return [null, null];
  definition.fields.forEach((field) => {
    const [fieldName, fieldDefinition] = convertFieldDefinition(field, `Type ${objectTypeName}`);
    converted[fieldName] = fieldDefinition;
  });
  return [objectTypeName, converted];
}
function convertName(nameObj, errDesc) {
  if (!isObject(nameObj) || !isString(nameObj.value)) {
    throw new Error(`${errDesc} does not have a valid name prop.`);
  }
  return nameObj.value;
}
function convertFieldDefinition(field, errDesc) {
  if (field.kind !== "FieldDefinition" || !isObject(field.type)) {
    throw new Error(`${errDesc} is not a valid ObjectTypeDefinition`);
  }
  const fieldName = convertName(field.name, errDesc);
  const converted = convertFieldDefinitionType(field.type, errDesc);
  converted.inputValues = field.arguments && field.arguments.length !== 0;
  return [fieldName, converted];
}
function convertFieldDefinitionType(fieldDefinitionType, errDesc, converted) {
  converted = converted || {
    nonNullTypeList: false,
    listType: false,
    nonNullTypeField: false,
    typeof: null
  };
  if (!isObject(fieldDefinitionType)) {
    throw new Error(`${errDesc} is not a valid Fielddefinition "type".`);
  }
  switch (fieldDefinitionType.kind) {
    case "NamedType":
      converted.typeof = convertName(fieldDefinitionType.name);
      return converted;
    case "NonNullType":
      if (fieldDefinitionType.type.kind === "NamedType") {
        converted.nonNullTypeField = true;
      } else {
        converted.nonNullTypeList = true;
      }
      return convertFieldDefinitionType(fieldDefinitionType.type, errDesc, converted);
    case "ListType":
      converted.listType = true;
      return convertFieldDefinitionType(fieldDefinitionType.type, errDesc, converted);
  }
}
function throwError(msg, code) {
  const err = new Error(msg);
  err.code = code;
  throw err;
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function isString(str) {
  return typeof str === "string";
}
function isFunction(func) {
  return typeof func === "function";
}
function isArray(array) {
  return Array.isArray(array);
}

// src/hooks/iff-else.ts
function iffElse(predicate, trueHook, falseHook) {
  return function(ctx) {
    const trueHooks = Array.isArray(trueHook) ? trueHook : typeof trueHook === "function" ? [trueHook] : void 0;
    const falseHooks = Array.isArray(falseHook) ? falseHook : typeof falseHook === "function" ? [falseHook] : void 0;
    const that = this;
    const check = typeof predicate === "function" ? predicate.apply(that, [ctx]) : !!predicate;
    if (!check) {
      return callHooks.call(that, ctx, falseHooks);
    }
    if (!isPromise(check)) {
      return callHooks.call(that, ctx, trueHooks);
    }
    return check.then((check1) => {
      const hooks = check1 ? trueHooks : falseHooks;
      return callHooks.call(that, ctx, hooks);
    });
  };
}
function callHooks(ctx, serviceHooks) {
  return serviceHooks ? combine(...serviceHooks).call(this, ctx) : ctx;
}

// src/hooks/iff.ts
function iff(predicate, ...hooks) {
  if (hooks.length && Array.isArray(hooks[0])) {
    hooks = hooks[0];
  }
  const iffWithoutElse = function(context) {
    return iffElse(predicate, hooks.slice())(context);
  };
  iffWithoutElse.else = (...falseHooks) => (context) => (
    // @ts-ignore
    iffElse(predicate, hooks.slice(), falseHooks.slice())(context)
  );
  return iffWithoutElse;
}
function keep(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "keep");
    const items = getItems(context);
    if (Array.isArray(items)) {
      replaceItems(
        context,
        items.map((item) => replaceItem(item, fieldNames))
      );
    } else {
      replaceItems(context, replaceItem(items, fieldNames));
    }
    return context;
  };
}
function replaceItem(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has__default.default(item, field))
      return;
    const value = _get3__default.default(item, field);
    _set3__default.default(newItem, field, value);
  });
  item = newItem;
  return item;
}
function keepInArray(arrayName, fieldNames) {
  return (context) => {
    const items = getItems(context);
    if (Array.isArray(items)) {
      items.forEach((item) => replaceIn(item, arrayName, fieldNames));
    } else {
      replaceIn(items, arrayName, fieldNames);
    }
    return context;
  };
}
function replaceIn(item, field, fieldNames) {
  const target = _get3__default.default(item, field);
  if (target) {
    if (!Array.isArray(target))
      throw new errors.BadRequest(
        `The 'field' param must lead to array. found type '${typeof target}' instead`
      );
    _set3__default.default(
      item,
      field,
      target.map((item2) => replaceItem2(item2, fieldNames))
    );
  }
}
function replaceItem2(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has__default.default(item, field))
      return;
    const value = _get3__default.default(item, field);
    _set3__default.default(newItem, field, value);
  });
  item = newItem;
  return item;
}

// src/hooks/keep-query.ts
function keepQuery(...fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "keepQuery");
    const query = context.params.query || {};
    context.params.query = pluck(query, fieldNames);
    return context;
  };
}
function keepQueryInArray(arrayName, fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "keepQueryInArray");
    replaceIn2(context.query, arrayName, fieldNames);
    return context;
  };
}
function replaceIn2(item, field, fieldNames) {
  const target = _get3__default.default(item, field);
  if (target) {
    if (!Array.isArray(target))
      throw new errors.BadRequest(
        `The 'field' param must lead to array. found type '${typeof target}' instead`
      );
    _set3__default.default(
      item,
      field,
      target.map((item2) => replaceItem3(item2, fieldNames))
    );
  }
}
function replaceItem3(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has__default.default(item, field))
      return;
    const value = _get3__default.default(item, field);
    _set3__default.default(newItem, field, value);
  });
  item = newItem;
  return item;
}
function lowerCase(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "lowercase");
    transformItems(getItems(context), fieldNames, (item, fieldName, value) => {
      if (value !== void 0) {
        if (typeof value !== "string" && value !== null) {
          throw new errors.BadRequest(`Expected string data. (lowercase ${fieldName})`);
        }
        _set3__default.default(item, fieldName, value ? value.toLowerCase() : value);
      }
    });
    return context;
  };
}
function mongoKeys(ObjectId, keyFields) {
  keyFields = Array.isArray(keyFields) ? keyFields : [keyFields];
  const keyLeaves = [];
  const keysInfo = keyFields.map((field) => {
    const fieldNames = field.split(".");
    const leaf = fieldNames.slice(-1)[0];
    keyLeaves.push(leaf);
    return { leaf, len: fieldNames.length, path: JSON.stringify(fieldNames) };
  });
  return (context) => {
    checkContext(context, "before", null, "mongoKeys");
    const query = context.params.query || {};
    traverser__default.default(query).forEach(function(node) {
      const typeofNode = typeof node;
      const key = this.key;
      const path = this.path;
      if (keyLeaves.indexOf(key) === -1)
        return;
      if (path.indexOf("$sort") !== -1)
        return;
      keysInfo.forEach((info) => {
        if (info.leaf === key && info.len <= path.length) {
          const endPath = path.slice(-info.len);
          if (JSON.stringify(endPath) === info.path) {
            if (typeofNode === "object" && node !== null && !Array.isArray(node)) {
              const actualProps = Object.keys(node);
              const onlyProp = actualProps[0];
              if (actualProps.length === 1 && onlyProp === "$in") {
                const newNode = { $in: wrapValue(node[onlyProp]) };
                this.update(newNode);
              }
            } else if (typeofNode === "string" || typeofNode === "number") {
              const newNode = wrapValue(node);
              this.update(newNode);
            }
          }
        }
      });
    });
    return context;
  };
  function wrapValue(value) {
    return Array.isArray(value) ? value.map((val) => new ObjectId(val)) : new ObjectId(value);
  }
}

// src/hooks/params-from-client.ts
function paramsFromClient(...whitelist) {
  return (context) => {
    const params = context.params;
    if (params?.query?.$client && typeof params.query.$client === "object") {
      const client = params.query.$client;
      whitelist.forEach((key) => {
        if (key in client) {
          params[key] = client[key];
        }
      });
      params.query = Object.assign({}, params.query);
      delete params.query.$client;
    }
    return context;
  };
}
function populate(options) {
  const typeofSchema = typeof options.schema;
  if ((typeofSchema !== "object" || options.schema === null) && typeofSchema !== "function") {
    throw new Error("Options.schema is not an object. (populate)");
  }
  return function(context) {
    const optionsDefault = {
      schema: {},
      checkPermissions: () => true,
      profile: false
    };
    if (context.params._populate === "skip") {
      return context;
    }
    return Promise.resolve().then(() => {
      const items = getItems(context);
      const options1 = Object.assign({}, optionsDefault, options);
      const { schema, checkPermissions } = options1;
      const schema1 = typeof schema === "function" ? schema(context, options1) : schema;
      const permissions = schema1.permissions || null;
      const baseService = schema1.service;
      const provider = "provider" in schema1 ? schema1.provider : context.params.provider;
      if (typeof checkPermissions !== "function") {
        throw new errors.BadRequest("Permissions param is not a function. (populate)");
      }
      if (baseService && context.path && baseService !== context.path) {
        throw new errors.BadRequest(`Schema is for ${baseService} not ${context.path}. (populate)`);
      }
      if (permissions && !checkPermissions(context, context.path, permissions, 0)) {
        throw new errors.BadRequest("Permissions do not allow this populate. (populate)");
      }
      if (typeof schema1 !== "object") {
        throw new errors.BadRequest("Schema does not resolve to an object. (populate)");
      }
      const include = [].concat(schema1.include || []).map((schema2) => {
        if ("provider" in schema2) {
          return schema2;
        } else {
          return Object.assign({}, schema2, { provider });
        }
      });
      return !include.length ? items : populateItemArray(options1, context, items, include, 0);
    }).then((items) => {
      replaceItems(context, items);
      return context;
    });
  };
}
function populateItemArray(options, context, items, includeSchema, depth) {
  if (items.toJSON || items.toObject) {
    throw new errors.BadRequest("Populate requires results to be plain JavaScript objects. (populate)");
  }
  if (!Array.isArray(items)) {
    return populateItem(options, context, items, includeSchema, depth + 1);
  }
  return Promise.all(
    items.map((item) => populateItem(options, context, item, includeSchema, depth + 1))
  );
}
function populateItem(options, context, item, includeSchema, depth) {
  const elapsed = {};
  const startAtAllIncludes = (/* @__PURE__ */ new Date()).getTime();
  const include = [].concat(includeSchema || []);
  if (!Object.prototype.hasOwnProperty.call(item, "_include"))
    item._include = [];
  return Promise.all(
    include.map((childSchema) => {
      const { query, select, parentField } = childSchema;
      if (!query && !select && (!parentField || _get3__default.default(item, parentField) === void 0)) {
        return void 0;
      }
      const startAtThisInclude = (/* @__PURE__ */ new Date()).getTime();
      return populateAddChild(options, context, item, childSchema, depth).then((result) => {
        const nameAs = childSchema.nameAs || childSchema.service;
        elapsed[nameAs] = getElapsed(options, startAtThisInclude, depth);
        return result;
      });
    })
  ).then((children) => {
    if (options.profile !== false) {
      elapsed.total = getElapsed(options, startAtAllIncludes, depth);
      item._elapsed = elapsed;
    }
    children.forEach((child) => {
      if (child) {
        _set3__default.default(item, child.nameAs, child.items);
      }
    });
    return item;
  });
}
function populateAddChild(options, context, parentItem, childSchema, depth) {
  const {
    childField,
    paginate,
    parentField,
    permissions,
    query,
    select,
    service,
    useInnerPopulate,
    provider
  } = childSchema;
  if (!service) {
    throw new errors.BadRequest("Child schema is missing the service property. (populate)");
  }
  if (!query && !select && !(parentField && childField)) {
    throw new errors.BadRequest("Child schema is missing parentField or childField property. (populate)");
  }
  if (permissions && !options.checkPermissions(context, service, permissions, depth)) {
    throw new errors.BadRequest(`Permissions for ${service} do not allow include. (populate)`);
  }
  const nameAs = childSchema.nameAs || service;
  if (parentItem._include.indexOf(nameAs) === -1)
    parentItem._include.push(nameAs);
  return Promise.resolve().then(() => select ? select(context, parentItem, depth) : {}).then((selectQuery) => {
    let sqlQuery = {};
    if (parentField) {
      const parentVal = _get3__default.default(parentItem, parentField);
      sqlQuery = { [childField]: Array.isArray(parentVal) ? { $in: parentVal } : parentVal };
    }
    const queryObj = Object.assign(
      {},
      query,
      sqlQuery,
      selectQuery
      // dynamic options override static ones
    );
    const serviceHandle = context.app.service(service);
    if (!serviceHandle) {
      throw new errors.BadRequest(`Service ${service} is not configured. (populate)`);
    }
    let paginateObj = { paginate: false };
    const paginateOption = paginate;
    if (paginateOption === true) {
      paginateObj = null;
    }
    if (typeof paginateOption === "number") {
      paginateObj = { paginate: { default: paginateOption } };
    }
    const params = Object.assign(
      {},
      context.params,
      paginateObj,
      { query: queryObj },
      useInnerPopulate ? {} : { _populate: "skip" },
      "provider" in childSchema ? { provider: childSchema.provider } : {}
    );
    return serviceHandle.find(params);
  }).then((result) => {
    result = result.data || result;
    if (result.length === 0) {
      return childSchema.asArray ? [] : null;
    }
    if (result.length === 1 && !childSchema.asArray) {
      result = result[0];
    }
    const include = [].concat(childSchema.include || []).map((schema) => {
      if ("provider" in schema) {
        return schema;
      } else {
        return Object.assign({}, schema, { provider });
      }
    });
    return childSchema.include && result ? populateItemArray(options, context, result, include, depth) : result;
  }).then((items) => ({ nameAs, items }));
}
function milliToNano(num) {
  return num * 1e6;
}
function getElapsed(options, startTime, depth) {
  if (options.profile === true) {
    return milliToNano((/* @__PURE__ */ new Date()).getTime() - startTime + 1e-3);
  }
  return depth;
}
function preventChanges(ifThrow, ...fieldNames) {
  if (typeof ifThrow === "string") {
    console.warn("**Deprecated** Use the preventChanges(true, ...fieldNames) syntax instead.");
    fieldNames = [ifThrow, ...fieldNames];
  }
  return (context) => {
    checkContext(context, "before", ["patch"], "preventChanges");
    let data = { ...context.data };
    fieldNames.forEach((name) => {
      if (_has__default.default(data, name)) {
        if (ifThrow) {
          throw new errors.BadRequest(`Field ${name} may not be patched. (preventChanges)`);
        }
        data = _omit__default.default(data, name);
      }
    });
    context.data = data;
    return context;
  };
}
function required(...fieldNames) {
  return (context) => {
    checkContext(context, "before", ["create", "update", "patch"], "required");
    const items = getItems(context);
    (Array.isArray(items) ? items : [items]).forEach((item) => {
      fieldNames.forEach((name) => {
        if (!_has__default.default(item, name))
          throw new errors.BadRequest(`Field ${name} does not exist. (required)`);
        const value = _get3__default.default(item, name);
        if (!value && value !== 0 && value !== false)
          throw new errors.BadRequest(`Field ${name} is null. (required)`);
      });
    });
  };
}

// src/utils/run-hook.ts
function runHook(context) {
  const extraContent = context;
  return (hookFunc) => (result) => {
    const ctx = Object.assign({}, { type: "after", params: {}, result }, extraContent);
    if (typeof result === "object" && result !== null && result.total && result.data) {
      ctx.method = "find";
    }
    return Promise.resolve().then(() => hookFunc(ctx)).then((newContext) => {
      if (!newContext) {
        return;
      }
      const result2 = newContext.result;
      if (typeof result2 === "object" && result2 !== null && result2.total && result2.data) {
        return newContext.result;
      }
      return newContext.result.data || newContext.result;
    });
  };
}
function runParallel(hook, clone2) {
  if (typeof hook !== "function") {
    throw new errors.BadRequest("Function not provided. (runParallel)");
  }
  return function(context) {
    const copy = clone2 ? clone2(context) : context;
    setTimeout(() => hook.call(this, copy));
  };
}

// src/hooks/sequelize-convert.ts
var methodsWithBeforeData = ["create", "update", "patch"];
var defaultConversions = {
  boolean: {
    sql: (boolean) => boolean ? 1 : 0,
    js: (numb) => !!numb
  },
  date: {
    sql: (dateNow) => dateNow,
    js: (sqlDate) => new Date(sqlDate).valueOf() || null
  },
  json: {
    sql: (obj) => JSON.stringify(obj),
    js: (str) => JSON.parse(str)
  }
};
function sequelizeConvert(converts, ignores, conversions) {
  const converter = sequelizeConversion(converts, ignores, conversions);
  return (context) => {
    if (context.type === "before" && !methodsWithBeforeData.includes(context.method))
      return context;
    const items = getItems(context);
    converter(context.type === "before" ? "sql" : "js", items);
    replaceItems(context, items);
    return context;
  };
}
function sequelizeConversion(converts, ignores, conversions = {}) {
  converts = converts || {};
  ignores = ignores || [];
  conversions.boolean = conversions.boolean || defaultConversions.boolean;
  conversions.date = conversions.date || defaultConversions.date;
  conversions.json = conversions.json || defaultConversions.json;
  const props = Object.keys(converts).filter((name) => !ignores.includes(name));
  return (sqlJs, recs) => {
    recs = Array.isArray(recs) ? recs : [recs];
    recs.forEach((rec) => {
      props.forEach((name) => {
        if (name in rec) {
          rec[name] = conversions[converts[name].toLowerCase()][sqlJs](rec[name]);
        }
      });
    });
  };
}
function serialize(schema1) {
  return (context) => {
    const schema = typeof schema1 === "function" ? schema1(context) : schema1;
    const schemaDirectives = ["computed", "exclude", "only"];
    replaceItems(context, serializeItems(getItems(context), schema));
    return context;
    function serializeItems(items, schema2) {
      if (!Array.isArray(items)) {
        return serializeItem(items, schema2);
      }
      return items.map((item) => serializeItem(item, schema2));
    }
    function serializeItem(item, schema2) {
      const computed = {};
      Object.keys(schema2.computed || {}).forEach((name) => {
        computed[name] = schema2.computed[name](item, context);
      });
      let only = schema2.only;
      only = typeof only === "string" ? [only] : only;
      if (only) {
        const newItem = {};
        only.concat("_include", "_elapsed", item._include || []).forEach((key) => {
          const value = _get3__default.default(item, key);
          if (value !== void 0) {
            _set3__default.default(newItem, key, value);
          }
        });
        item = newItem;
      }
      let exclude = schema2.exclude;
      exclude = typeof exclude === "string" ? [exclude] : exclude;
      if (exclude) {
        item = _omit__default.default(item, exclude);
      }
      const _computed = Object.keys(computed);
      item = Object.assign({}, item, computed, _computed.length ? { _computed } : {});
      Object.keys(schema2).forEach((key) => {
        if (!schemaDirectives.includes(key) && typeof item[key] === "object") {
          item[key] = serializeItems(item[key], schema2[key]);
        }
      });
      return item;
    }
  };
}
var debug3 = makeDebug__default.default("feathers-hooks-common/setField");
function setField({
  as,
  from,
  allowUndefined = false
}) {
  if (!as || !from) {
    throw new Error("'as' and 'from' options have to be set");
  }
  return (context) => {
    const { params } = context;
    checkContext(context, "before", null, "setField");
    const value = _get3__default.default(context, from);
    if (value === void 0) {
      if (!params.provider || allowUndefined) {
        debug3(`Skipping call with value ${from} not set`);
        return context;
      }
      throw new errors.Forbidden(`Expected field ${as} not available`);
    }
    debug3(`Setting value '${value}' from '${from}' as '${as}'`);
    return _setWith__default.default(context, as, value, _clone__default.default);
  };
}
function setNow(...fieldNames) {
  if (!fieldNames.length) {
    throw new errors.BadRequest("Field name is required. (setNow)");
  }
  return (context) => {
    setFields(getItems(context), () => /* @__PURE__ */ new Date(), fieldNames, "setNow");
    return context;
  };
}
function setSlug(slug, fieldName) {
  return (context) => {
    if (typeof fieldName !== "string") {
      fieldName = `query.${slug}`;
    }
    if (context.type === "after") {
      throw new errors.GeneralError("Cannot set slug on after hook. (setSlug)");
    }
    if (context.params && context.params.provider === "rest") {
      const value = context.params.route[slug];
      if (typeof value === "string" && value[0] !== ":") {
        _set3__default.default(context.params, fieldName, value);
      }
    }
  };
}
function sifter(siftFunc) {
  return (context) => {
    checkContext(context, "after", "find", "sifter");
    if (typeof siftFunc !== "function") {
      throw new errors.BadRequest("The sifter param must be a function. (sifter)");
    }
    const sifter2 = siftFunc(context);
    if (typeof sifter2 !== "function") {
      throw new errors.BadRequest("The result of calling the sifter param must be a function. (sifter)");
    }
    replaceItems(context, getItems(context).filter(sifter2));
    return context;
  };
}

// src/hooks/soft-delete.ts
var defaultQuery = { deleted: { $ne: true } };
var defaultData = { deleted: true };
var getValue = (value, ...args) => {
  if (typeof value === "function") {
    return Promise.resolve(value(...args));
  }
  return Promise.resolve(value);
};
function softDelete({
  deletedQuery = defaultQuery,
  removeData = defaultData
} = {}) {
  return async (context) => {
    const { service, method, params } = context;
    const { disableSoftDelete, query = {} } = params;
    checkContext(context, "before", null, "softDelete");
    if (disableSoftDelete) {
      return context;
    }
    const deleteQuery = await getValue(deletedQuery, context);
    context.params.query = Object.assign({}, query, deleteQuery);
    if (method === "remove") {
      const data = await getValue(removeData, context);
      const result = await service.patch(context.id, data, params);
      context.result = result;
    }
    return context;
  };
}
function stashBefore(fieldName) {
  const beforeField = fieldName || "before";
  return (context) => {
    checkContext(context, "before", ["get", "update", "patch", "remove"], "stashBefore");
    if (context.params.disableStashBefore) {
      return context;
    }
    if ((context.id === null || context.id === void 0) && !context.params.query) {
      throw new errors.BadRequest("Id is required. (stashBefore)");
    }
    const params = context.method === "get" ? context.params : {
      provider: context.params.provider,
      // @ts-ignore
      authenticated: context.params.authenticated,
      // @ts-ignore
      user: context.params.user
    };
    return context.service.get(context.id, {
      ...params,
      // @ts-ignore
      query: params.query || {},
      // @ts-ignore
      disableStashBefore: true
    }).then((data) => {
      context.params[beforeField] = JSON.parse(JSON.stringify(data));
      return context;
    }).catch(() => context);
  };
}

// src/hooks/traverse.ts
function traverse3(transformer, getObject) {
  return (context) => {
    const items = typeof getObject === "function" ? getObject(context) : getObject || getItems(context);
    traverse(items, transformer);
    return context;
  };
}

// src/hooks/unless.ts
function unless(predicate, ...hooks) {
  return iffElse(predicate, void 0, hooks.slice());
}
function validate(validator) {
  return (context) => {
    checkContext(context, "before", ["create", "update", "patch"], "validate");
    if (typeof validator !== "function") {
      throw new errors.BadRequest("Expected validator function. (validate)");
    }
    const results = validator(getItems(context), context);
    if (isPromise(results)) {
      return results.then((convertedValues) => {
        if (convertedValues) {
          replaceItems(context, convertedValues);
        }
        return context;
      });
    }
    if (results && Object.keys(results).length) {
      throw new errors.BadRequest({ errors: results });
    }
    return context;
  };
}
function validateSchema(schema, ajvOrAjv, options = { allErrors: true }) {
  const addNewError = options?.addNewError || addNewErrorDflt;
  let ajv;
  let Ajv;
  if (typeof ajvOrAjv.addKeyword !== "function") {
    Ajv = ajvOrAjv;
    ajv = new Ajv(options);
  } else {
    ajv = ajvOrAjv;
  }
  const validate2 = typeof schema === "string" ? ajv.getSchema(schema) : ajv.compile(schema);
  return (context) => {
    const items = getItems(context);
    const itemsArray = Array.isArray(items) ? items : [items];
    const itemsLen = itemsArray.length;
    let errorMessages = null;
    let invalid = false;
    if (validate2.schema.$async) {
      return Promise.all(
        itemsArray.map((item, index) => {
          return validate2(item).catch((err) => {
            if (!(err instanceof ajv.constructor.ValidationError))
              throw err;
            invalid = true;
            addErrors(err.errors, index);
          });
        })
      ).then(() => {
        if (invalid) {
          throw new errors.BadRequest("Data does not match schema", { errors: errorMessages });
        }
      });
    }
    itemsArray.forEach((item, index) => {
      if (!validate2(item)) {
        invalid = true;
        addErrors(validate2.errors, index);
      }
    });
    if (invalid) {
      throw new errors.BadRequest("Data does not match schema", { errors: errorMessages });
    }
    function addErrors(errors, index) {
      errors.forEach((ajvError) => {
        errorMessages = addNewError(errorMessages, ajvError, itemsLen, index);
      });
    }
    return context;
  };
}
function addNewErrorDflt(errorMessages, ajvError, itemsLen, index) {
  const leader = itemsLen === 1 ? "" : `in row ${index + 1} of ${itemsLen}, `;
  let message;
  if (ajvError.dataPath) {
    message = `'${leader}${ajvError.dataPath.substring(1)}' ${ajvError.message}`;
  } else {
    message = `${leader}${ajvError.message}`;
  }
  if (ajvError.params && ajvError.params.additionalProperty) {
    message += `: '${ajvError.params.additionalProperty}'`;
  }
  return (errorMessages || []).concat(message);
}
var stndAuthProps = ["provider", "authenticated", "user"];
var defaults = {
  propNames: stndAuthProps,
  newProps: {}
};
function callingParamsDefaults(propNames, newProps) {
  if (propNames) {
    defaults.propNames = Array.isArray(propNames) ? propNames : [propNames];
  }
  if (newProps) {
    defaults.newProps = newProps;
  }
}
function callingParams({
  query,
  propNames = [],
  newProps = {},
  hooksToDisable = [],
  ignoreDefaults
} = {}) {
  return (context) => {
    propNames = Array.isArray(propNames) ? propNames : [propNames];
    hooksToDisable = Array.isArray(hooksToDisable) ? hooksToDisable : [hooksToDisable];
    const newParams = query ? { query } : {};
    const allPropNames = ignoreDefaults ? propNames : [...defaults.propNames, ...propNames];
    allPropNames.forEach((name) => {
      if (name) {
        const value = _get3__default.default(context.params, name);
        if (value !== void 0) {
          _set3__default.default(newParams, name, value);
        }
      }
    });
    Object.assign(newParams, ignoreDefaults ? {} : defaults.newProps, newProps);
    hooksToDisable.forEach((name) => {
      switch (name) {
        case "populate":
        case "fastJoin":
          newParams._populate = "skip";
          break;
        case "softDelete":
          newParams.query = newParams.query || {};
          newParams.query.$disableSoftDelete = true;
          break;
        case "softDelete2":
          newParams.$disableSoftDelete2 = true;
          break;
        case "ignoreDeletedAt":
          newParams.$ignoreDeletedAt = true;
          break;
        case "stashBefore":
          newParams.disableStashBefore = true;
          break;
      }
    });
    return newParams;
  };
}
function makeCallingParams(context, query, include, inject = {}) {
  return callingParams({
    query,
    propNames: include === void 0 ? ["provider", "authenticated", "user"] : Array.isArray(include) ? include : [include],
    newProps: Object.assign({}, { _populate: "skip" }, inject),
    ignoreDefaults: true
  })(context);
}

// src/utils/every.ts
function every(...predicates) {
  return async function(...fnArgs) {
    const promises = predicates.map((fn) => fn.apply(this, fnArgs));
    const results = await Promise.all(promises);
    return await Promise.resolve(results.every((result) => !!result));
  };
}
function isNot(predicate) {
  if (typeof predicate !== "function") {
    throw new errors.MethodNotAllowed("Expected function as param. (isNot)");
  }
  return (context) => {
    const result = predicate(context);
    if (!isPromise(result)) {
      return !result;
    }
    return result.then((result1) => !result1);
  };
}
function isProvider(...providers) {
  if (!providers.length) {
    throw new errors.MethodNotAllowed("Calling isProvider predicate incorrectly.");
  }
  return (context) => {
    const hookProvider = context.params.provider;
    return providers.some(
      (provider) => provider === hookProvider || provider === "server" && !hookProvider || provider === "external" && !!hookProvider
    );
  };
}

// src/utils/params-for-server.ts
function paramsForServer(params, ...whitelist) {
  const ifWhitelist = !!whitelist.length;
  const _params = Object.assign({}, params);
  _params.query = _params.query || {};
  _params.query.$client = _params.query.$client || {};
  Object.keys(_params).forEach((key) => {
    if (key !== "query") {
      if (!ifWhitelist || whitelist.includes(key)) {
        _params.query.$client[key] = _params[key];
      }
      delete _params[key];
    }
  });
  return _params;
}

// src/utils/some.ts
function some(...predicates) {
  return async function(context) {
    const promises = predicates.map((fn) => fn.apply(this, [context]));
    const results = await Promise.all(promises);
    return await Promise.resolve(results.some((result) => !!result));
  };
}

exports.actOnDefault = actOnDefault;
exports.actOnDispatch = actOnDispatch;
exports.alterItems = alterItems;
exports.cache = cache;
exports.callingParams = callingParams;
exports.callingParamsDefaults = callingParamsDefaults;
exports.checkContext = checkContext;
exports.checkContextIf = checkContextIf;
exports.combine = combine;
exports.dePopulate = dePopulate;
exports.debug = debug;
exports.disablePagination = disablePagination;
exports.disallow = disallow;
exports.discard = discard;
exports.discardQuery = discardQuery;
exports.every = every;
exports.fastJoin = fastJoin;
exports.fgraphql = fgraphql;
exports.getItems = getItems;
exports.hookTypes = hookTypes;
exports.iff = iff;
exports.iffElse = iffElse;
exports.isNot = isNot;
exports.isProvider = isProvider;
exports.keep = keep;
exports.keepInArray = keepInArray;
exports.keepQuery = keepQuery;
exports.keepQueryInArray = keepQueryInArray;
exports.lowerCase = lowerCase;
exports.makeCallingParams = makeCallingParams;
exports.methodNames = methodNames;
exports.mongoKeys = mongoKeys;
exports.paramsForServer = paramsForServer;
exports.paramsFromClient = paramsFromClient;
exports.populate = populate;
exports.preventChanges = preventChanges;
exports.replaceItems = replaceItems;
exports.required = required;
exports.runHook = runHook;
exports.runParallel = runParallel;
exports.sequelizeConvert = sequelizeConvert;
exports.serialize = serialize;
exports.setField = setField;
exports.setNow = setNow;
exports.setSlug = setSlug;
exports.sifter = sifter;
exports.softDelete = softDelete;
exports.some = some;
exports.stashBefore = stashBefore;
exports.traverse = traverse3;
exports.unless = unless;
exports.validate = validate;
exports.validateSchema = validateSchema;
exports.when = iff;
